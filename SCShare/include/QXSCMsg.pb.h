// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: QXSCMsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_QXSCMsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_QXSCMsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_QXSCMsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_QXSCMsg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_QXSCMsg_2eproto;
namespace QXSCMsg {
class CipherContent;
struct CipherContentDefaultTypeInternal;
extern CipherContentDefaultTypeInternal _CipherContent_default_instance_;
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class ClientRegisterChallengeReply;
struct ClientRegisterChallengeReplyDefaultTypeInternal;
extern ClientRegisterChallengeReplyDefaultTypeInternal _ClientRegisterChallengeReply_default_instance_;
class ClientRegisterRequest;
struct ClientRegisterRequestDefaultTypeInternal;
extern ClientRegisterRequestDefaultTypeInternal _ClientRegisterRequest_default_instance_;
class MsgBase;
struct MsgBaseDefaultTypeInternal;
extern MsgBaseDefaultTypeInternal _MsgBase_default_instance_;
class MsgPayload;
struct MsgPayloadDefaultTypeInternal;
extern MsgPayloadDefaultTypeInternal _MsgPayload_default_instance_;
class ServerInfo;
struct ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class ServerRegisterChallenge;
struct ServerRegisterChallengeDefaultTypeInternal;
extern ServerRegisterChallengeDefaultTypeInternal _ServerRegisterChallenge_default_instance_;
class ServerRegisterFinish;
struct ServerRegisterFinishDefaultTypeInternal;
extern ServerRegisterFinishDefaultTypeInternal _ServerRegisterFinish_default_instance_;
class TransMsg;
struct TransMsgDefaultTypeInternal;
extern TransMsgDefaultTypeInternal _TransMsg_default_instance_;
}  // namespace QXSCMsg
PROTOBUF_NAMESPACE_OPEN
template<> ::QXSCMsg::CipherContent* Arena::CreateMaybeMessage<::QXSCMsg::CipherContent>(Arena*);
template<> ::QXSCMsg::ClientInfo* Arena::CreateMaybeMessage<::QXSCMsg::ClientInfo>(Arena*);
template<> ::QXSCMsg::ClientRegisterChallengeReply* Arena::CreateMaybeMessage<::QXSCMsg::ClientRegisterChallengeReply>(Arena*);
template<> ::QXSCMsg::ClientRegisterRequest* Arena::CreateMaybeMessage<::QXSCMsg::ClientRegisterRequest>(Arena*);
template<> ::QXSCMsg::MsgBase* Arena::CreateMaybeMessage<::QXSCMsg::MsgBase>(Arena*);
template<> ::QXSCMsg::MsgPayload* Arena::CreateMaybeMessage<::QXSCMsg::MsgPayload>(Arena*);
template<> ::QXSCMsg::ServerInfo* Arena::CreateMaybeMessage<::QXSCMsg::ServerInfo>(Arena*);
template<> ::QXSCMsg::ServerRegisterChallenge* Arena::CreateMaybeMessage<::QXSCMsg::ServerRegisterChallenge>(Arena*);
template<> ::QXSCMsg::ServerRegisterFinish* Arena::CreateMaybeMessage<::QXSCMsg::ServerRegisterFinish>(Arena*);
template<> ::QXSCMsg::TransMsg* Arena::CreateMaybeMessage<::QXSCMsg::TransMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace QXSCMsg {

enum MsgType : int {
  QX_SC_MSG_TYPE_UKNOWN = 0,
  QX_SC_MSG_TYPE_REGISTER_REQUEST = 1,
  QX_SC_MSG_TYPE_REGISTER_CHALLENGE = 2,
  QX_SC_MSG_TYPE_REGISTER_CHALLENGE_REPLY = 3,
  QX_SC_MSG_TYPE_REGISTER_FINISH = 4,
  QX_SC_MSG_TYPE_MSG_TRANS_C_2_S = 100,
  QX_SC_MSG_TYPE_MSG_TRANS_S_2_C = 101,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = QX_SC_MSG_TYPE_UKNOWN;
constexpr MsgType MsgType_MAX = QX_SC_MSG_TYPE_MSG_TRANS_S_2_C;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum CipherSuite : int {
  QX_SC_CIPHER_SUITE_NONE = 0,
  QX_SC_CIPHER_SUITE_SM4 = 1,
  CipherSuite_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CipherSuite_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CipherSuite_IsValid(int value);
constexpr CipherSuite CipherSuite_MIN = QX_SC_CIPHER_SUITE_NONE;
constexpr CipherSuite CipherSuite_MAX = QX_SC_CIPHER_SUITE_SM4;
constexpr int CipherSuite_ARRAYSIZE = CipherSuite_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CipherSuite_descriptor();
template<typename T>
inline const std::string& CipherSuite_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CipherSuite>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CipherSuite_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CipherSuite_descriptor(), enum_t_value);
}
inline bool CipherSuite_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CipherSuite* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CipherSuite>(
    CipherSuite_descriptor(), name, value);
}
// ===================================================================

class MsgPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.MsgPayload) */ {
 public:
  inline MsgPayload() : MsgPayload(nullptr) {}
  ~MsgPayload() override;
  explicit PROTOBUF_CONSTEXPR MsgPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPayload(const MsgPayload& from);
  MsgPayload(MsgPayload&& from) noexcept
    : MsgPayload() {
    *this = ::std::move(from);
  }

  inline MsgPayload& operator=(const MsgPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPayload& operator=(MsgPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgPayload* internal_default_instance() {
    return reinterpret_cast<const MsgPayload*>(
               &_MsgPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgPayload& a, MsgPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgPayload& from) {
    MsgPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.MsgPayload";
  }
  protected:
  explicit MsgPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBussinessKeyFieldNumber = 3,
    kClientInfoFieldNumber = 4,
    kServerInfoFieldNumber = 5,
    kMsgBaseFieldNumber = 7,
    kTimestampFieldNumber = 2,
    kTransIdFieldNumber = 1,
    kErrCodeFieldNumber = 6,
  };
  // string bussinessKey = 3;
  void clear_bussinesskey();
  const std::string& bussinesskey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bussinesskey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bussinesskey();
  PROTOBUF_NODISCARD std::string* release_bussinesskey();
  void set_allocated_bussinesskey(std::string* bussinesskey);
  private:
  const std::string& _internal_bussinesskey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bussinesskey(const std::string& value);
  std::string* _internal_mutable_bussinesskey();
  public:

  // .QXSCMsg.ClientInfo clientInfo = 4;
  bool has_clientinfo() const;
  private:
  bool _internal_has_clientinfo() const;
  public:
  void clear_clientinfo();
  const ::QXSCMsg::ClientInfo& clientinfo() const;
  PROTOBUF_NODISCARD ::QXSCMsg::ClientInfo* release_clientinfo();
  ::QXSCMsg::ClientInfo* mutable_clientinfo();
  void set_allocated_clientinfo(::QXSCMsg::ClientInfo* clientinfo);
  private:
  const ::QXSCMsg::ClientInfo& _internal_clientinfo() const;
  ::QXSCMsg::ClientInfo* _internal_mutable_clientinfo();
  public:
  void unsafe_arena_set_allocated_clientinfo(
      ::QXSCMsg::ClientInfo* clientinfo);
  ::QXSCMsg::ClientInfo* unsafe_arena_release_clientinfo();

  // .QXSCMsg.ServerInfo serverInfo = 5;
  bool has_serverinfo() const;
  private:
  bool _internal_has_serverinfo() const;
  public:
  void clear_serverinfo();
  const ::QXSCMsg::ServerInfo& serverinfo() const;
  PROTOBUF_NODISCARD ::QXSCMsg::ServerInfo* release_serverinfo();
  ::QXSCMsg::ServerInfo* mutable_serverinfo();
  void set_allocated_serverinfo(::QXSCMsg::ServerInfo* serverinfo);
  private:
  const ::QXSCMsg::ServerInfo& _internal_serverinfo() const;
  ::QXSCMsg::ServerInfo* _internal_mutable_serverinfo();
  public:
  void unsafe_arena_set_allocated_serverinfo(
      ::QXSCMsg::ServerInfo* serverinfo);
  ::QXSCMsg::ServerInfo* unsafe_arena_release_serverinfo();

  // .QXSCMsg.MsgBase msgBase = 7;
  bool has_msgbase() const;
  private:
  bool _internal_has_msgbase() const;
  public:
  void clear_msgbase();
  const ::QXSCMsg::MsgBase& msgbase() const;
  PROTOBUF_NODISCARD ::QXSCMsg::MsgBase* release_msgbase();
  ::QXSCMsg::MsgBase* mutable_msgbase();
  void set_allocated_msgbase(::QXSCMsg::MsgBase* msgbase);
  private:
  const ::QXSCMsg::MsgBase& _internal_msgbase() const;
  ::QXSCMsg::MsgBase* _internal_mutable_msgbase();
  public:
  void unsafe_arena_set_allocated_msgbase(
      ::QXSCMsg::MsgBase* msgbase);
  ::QXSCMsg::MsgBase* unsafe_arena_release_msgbase();

  // uint64 timestamp = 2;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 transId = 1;
  void clear_transid();
  uint32_t transid() const;
  void set_transid(uint32_t value);
  private:
  uint32_t _internal_transid() const;
  void _internal_set_transid(uint32_t value);
  public:

  // int32 errCode = 6;
  void clear_errcode();
  int32_t errcode() const;
  void set_errcode(int32_t value);
  private:
  int32_t _internal_errcode() const;
  void _internal_set_errcode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QXSCMsg.MsgPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bussinesskey_;
    ::QXSCMsg::ClientInfo* clientinfo_;
    ::QXSCMsg::ServerInfo* serverinfo_;
    ::QXSCMsg::MsgBase* msgbase_;
    uint64_t timestamp_;
    uint32_t transid_;
    int32_t errcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {}
  ~ClientInfo() override;
  explicit PROTOBUF_CONSTEXPR ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientInfo& from) {
    ClientInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // uint32 clientId = 1;
  void clear_clientid();
  uint32_t clientid() const;
  void set_clientid(uint32_t value);
  private:
  uint32_t _internal_clientid() const;
  void _internal_set_clientid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QXSCMsg.ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {}
  ~ServerInfo() override;
  explicit PROTOBUF_CONSTEXPR ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfo(const ServerInfo& from);
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerInfo& from) {
    ServerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.ServerInfo";
  }
  protected:
  explicit ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerNameFieldNumber = 2,
    kServerIdFieldNumber = 1,
  };
  // string serverName = 2;
  void clear_servername();
  const std::string& servername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servername();
  PROTOBUF_NODISCARD std::string* release_servername();
  void set_allocated_servername(std::string* servername);
  private:
  const std::string& _internal_servername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servername(const std::string& value);
  std::string* _internal_mutable_servername();
  public:

  // uint32 serverId = 1;
  void clear_serverid();
  uint32_t serverid() const;
  void set_serverid(uint32_t value);
  private:
  uint32_t _internal_serverid() const;
  void _internal_set_serverid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QXSCMsg.ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servername_;
    uint32_t serverid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgBase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.MsgBase) */ {
 public:
  inline MsgBase() : MsgBase(nullptr) {}
  ~MsgBase() override;
  explicit PROTOBUF_CONSTEXPR MsgBase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBase(const MsgBase& from);
  MsgBase(MsgBase&& from) noexcept
    : MsgBase() {
    *this = ::std::move(from);
  }

  inline MsgBase& operator=(const MsgBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBase& operator=(MsgBase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBase& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBase* internal_default_instance() {
    return reinterpret_cast<const MsgBase*>(
               &_MsgBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgBase& a, MsgBase& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBase& from) {
    MsgBase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.MsgBase";
  }
  protected:
  explicit MsgBase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterRequestFieldNumber = 2,
    kRegisterChallengeFieldNumber = 3,
    kRegisterChallengeReplyFieldNumber = 4,
    kRegisterFinishFieldNumber = 5,
    kTransMsgFieldNumber = 6,
    kMsgTypeFieldNumber = 1,
  };
  // .QXSCMsg.ClientRegisterRequest registerRequest = 2;
  bool has_registerrequest() const;
  private:
  bool _internal_has_registerrequest() const;
  public:
  void clear_registerrequest();
  const ::QXSCMsg::ClientRegisterRequest& registerrequest() const;
  PROTOBUF_NODISCARD ::QXSCMsg::ClientRegisterRequest* release_registerrequest();
  ::QXSCMsg::ClientRegisterRequest* mutable_registerrequest();
  void set_allocated_registerrequest(::QXSCMsg::ClientRegisterRequest* registerrequest);
  private:
  const ::QXSCMsg::ClientRegisterRequest& _internal_registerrequest() const;
  ::QXSCMsg::ClientRegisterRequest* _internal_mutable_registerrequest();
  public:
  void unsafe_arena_set_allocated_registerrequest(
      ::QXSCMsg::ClientRegisterRequest* registerrequest);
  ::QXSCMsg::ClientRegisterRequest* unsafe_arena_release_registerrequest();

  // .QXSCMsg.ServerRegisterChallenge registerChallenge = 3;
  bool has_registerchallenge() const;
  private:
  bool _internal_has_registerchallenge() const;
  public:
  void clear_registerchallenge();
  const ::QXSCMsg::ServerRegisterChallenge& registerchallenge() const;
  PROTOBUF_NODISCARD ::QXSCMsg::ServerRegisterChallenge* release_registerchallenge();
  ::QXSCMsg::ServerRegisterChallenge* mutable_registerchallenge();
  void set_allocated_registerchallenge(::QXSCMsg::ServerRegisterChallenge* registerchallenge);
  private:
  const ::QXSCMsg::ServerRegisterChallenge& _internal_registerchallenge() const;
  ::QXSCMsg::ServerRegisterChallenge* _internal_mutable_registerchallenge();
  public:
  void unsafe_arena_set_allocated_registerchallenge(
      ::QXSCMsg::ServerRegisterChallenge* registerchallenge);
  ::QXSCMsg::ServerRegisterChallenge* unsafe_arena_release_registerchallenge();

  // .QXSCMsg.ClientRegisterChallengeReply registerChallengeReply = 4;
  bool has_registerchallengereply() const;
  private:
  bool _internal_has_registerchallengereply() const;
  public:
  void clear_registerchallengereply();
  const ::QXSCMsg::ClientRegisterChallengeReply& registerchallengereply() const;
  PROTOBUF_NODISCARD ::QXSCMsg::ClientRegisterChallengeReply* release_registerchallengereply();
  ::QXSCMsg::ClientRegisterChallengeReply* mutable_registerchallengereply();
  void set_allocated_registerchallengereply(::QXSCMsg::ClientRegisterChallengeReply* registerchallengereply);
  private:
  const ::QXSCMsg::ClientRegisterChallengeReply& _internal_registerchallengereply() const;
  ::QXSCMsg::ClientRegisterChallengeReply* _internal_mutable_registerchallengereply();
  public:
  void unsafe_arena_set_allocated_registerchallengereply(
      ::QXSCMsg::ClientRegisterChallengeReply* registerchallengereply);
  ::QXSCMsg::ClientRegisterChallengeReply* unsafe_arena_release_registerchallengereply();

  // .QXSCMsg.ServerRegisterFinish registerFinish = 5;
  bool has_registerfinish() const;
  private:
  bool _internal_has_registerfinish() const;
  public:
  void clear_registerfinish();
  const ::QXSCMsg::ServerRegisterFinish& registerfinish() const;
  PROTOBUF_NODISCARD ::QXSCMsg::ServerRegisterFinish* release_registerfinish();
  ::QXSCMsg::ServerRegisterFinish* mutable_registerfinish();
  void set_allocated_registerfinish(::QXSCMsg::ServerRegisterFinish* registerfinish);
  private:
  const ::QXSCMsg::ServerRegisterFinish& _internal_registerfinish() const;
  ::QXSCMsg::ServerRegisterFinish* _internal_mutable_registerfinish();
  public:
  void unsafe_arena_set_allocated_registerfinish(
      ::QXSCMsg::ServerRegisterFinish* registerfinish);
  ::QXSCMsg::ServerRegisterFinish* unsafe_arena_release_registerfinish();

  // .QXSCMsg.TransMsg transMsg = 6;
  bool has_transmsg() const;
  private:
  bool _internal_has_transmsg() const;
  public:
  void clear_transmsg();
  const ::QXSCMsg::TransMsg& transmsg() const;
  PROTOBUF_NODISCARD ::QXSCMsg::TransMsg* release_transmsg();
  ::QXSCMsg::TransMsg* mutable_transmsg();
  void set_allocated_transmsg(::QXSCMsg::TransMsg* transmsg);
  private:
  const ::QXSCMsg::TransMsg& _internal_transmsg() const;
  ::QXSCMsg::TransMsg* _internal_mutable_transmsg();
  public:
  void unsafe_arena_set_allocated_transmsg(
      ::QXSCMsg::TransMsg* transmsg);
  ::QXSCMsg::TransMsg* unsafe_arena_release_transmsg();

  // uint32 msgType = 1;
  void clear_msgtype();
  uint32_t msgtype() const;
  void set_msgtype(uint32_t value);
  private:
  uint32_t _internal_msgtype() const;
  void _internal_set_msgtype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QXSCMsg.MsgBase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::QXSCMsg::ClientRegisterRequest* registerrequest_;
    ::QXSCMsg::ServerRegisterChallenge* registerchallenge_;
    ::QXSCMsg::ClientRegisterChallengeReply* registerchallengereply_;
    ::QXSCMsg::ServerRegisterFinish* registerfinish_;
    ::QXSCMsg::TransMsg* transmsg_;
    uint32_t msgtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class ClientRegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.ClientRegisterRequest) */ {
 public:
  inline ClientRegisterRequest() : ClientRegisterRequest(nullptr) {}
  ~ClientRegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR ClientRegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientRegisterRequest(const ClientRegisterRequest& from);
  ClientRegisterRequest(ClientRegisterRequest&& from) noexcept
    : ClientRegisterRequest() {
    *this = ::std::move(from);
  }

  inline ClientRegisterRequest& operator=(const ClientRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientRegisterRequest& operator=(ClientRegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientRegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientRegisterRequest* internal_default_instance() {
    return reinterpret_cast<const ClientRegisterRequest*>(
               &_ClientRegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClientRegisterRequest& a, ClientRegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientRegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientRegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientRegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientRegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientRegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientRegisterRequest& from) {
    ClientRegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientRegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.ClientRegisterRequest";
  }
  protected:
  explicit ClientRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kCipherSuiteFieldNumber = 2,
  };
  // uint32 clientId = 1;
  void clear_clientid();
  uint32_t clientid() const;
  void set_clientid(uint32_t value);
  private:
  uint32_t _internal_clientid() const;
  void _internal_set_clientid(uint32_t value);
  public:

  // uint32 cipherSuite = 2;
  void clear_ciphersuite();
  uint32_t ciphersuite() const;
  void set_ciphersuite(uint32_t value);
  private:
  uint32_t _internal_ciphersuite() const;
  void _internal_set_ciphersuite(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QXSCMsg.ClientRegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t clientid_;
    uint32_t ciphersuite_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class ServerRegisterChallenge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.ServerRegisterChallenge) */ {
 public:
  inline ServerRegisterChallenge() : ServerRegisterChallenge(nullptr) {}
  ~ServerRegisterChallenge() override;
  explicit PROTOBUF_CONSTEXPR ServerRegisterChallenge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerRegisterChallenge(const ServerRegisterChallenge& from);
  ServerRegisterChallenge(ServerRegisterChallenge&& from) noexcept
    : ServerRegisterChallenge() {
    *this = ::std::move(from);
  }

  inline ServerRegisterChallenge& operator=(const ServerRegisterChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerRegisterChallenge& operator=(ServerRegisterChallenge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerRegisterChallenge& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerRegisterChallenge* internal_default_instance() {
    return reinterpret_cast<const ServerRegisterChallenge*>(
               &_ServerRegisterChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ServerRegisterChallenge& a, ServerRegisterChallenge& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerRegisterChallenge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerRegisterChallenge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerRegisterChallenge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerRegisterChallenge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerRegisterChallenge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerRegisterChallenge& from) {
    ServerRegisterChallenge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerRegisterChallenge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.ServerRegisterChallenge";
  }
  protected:
  explicit ServerRegisterChallenge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCipherRandFieldNumber = 1,
  };
  // bytes cipherRand = 1;
  void clear_cipherrand();
  const std::string& cipherrand() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cipherrand(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cipherrand();
  PROTOBUF_NODISCARD std::string* release_cipherrand();
  void set_allocated_cipherrand(std::string* cipherrand);
  private:
  const std::string& _internal_cipherrand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cipherrand(const std::string& value);
  std::string* _internal_mutable_cipherrand();
  public:

  // @@protoc_insertion_point(class_scope:QXSCMsg.ServerRegisterChallenge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cipherrand_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class ClientRegisterChallengeReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.ClientRegisterChallengeReply) */ {
 public:
  inline ClientRegisterChallengeReply() : ClientRegisterChallengeReply(nullptr) {}
  ~ClientRegisterChallengeReply() override;
  explicit PROTOBUF_CONSTEXPR ClientRegisterChallengeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientRegisterChallengeReply(const ClientRegisterChallengeReply& from);
  ClientRegisterChallengeReply(ClientRegisterChallengeReply&& from) noexcept
    : ClientRegisterChallengeReply() {
    *this = ::std::move(from);
  }

  inline ClientRegisterChallengeReply& operator=(const ClientRegisterChallengeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientRegisterChallengeReply& operator=(ClientRegisterChallengeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientRegisterChallengeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientRegisterChallengeReply* internal_default_instance() {
    return reinterpret_cast<const ClientRegisterChallengeReply*>(
               &_ClientRegisterChallengeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClientRegisterChallengeReply& a, ClientRegisterChallengeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientRegisterChallengeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientRegisterChallengeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientRegisterChallengeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientRegisterChallengeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientRegisterChallengeReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientRegisterChallengeReply& from) {
    ClientRegisterChallengeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientRegisterChallengeReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.ClientRegisterChallengeReply";
  }
  protected:
  explicit ClientRegisterChallengeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlainRandFieldNumber = 1,
    kCipherRandFieldNumber = 2,
  };
  // bytes plainRand = 1;
  void clear_plainrand();
  const std::string& plainrand() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plainrand(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plainrand();
  PROTOBUF_NODISCARD std::string* release_plainrand();
  void set_allocated_plainrand(std::string* plainrand);
  private:
  const std::string& _internal_plainrand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plainrand(const std::string& value);
  std::string* _internal_mutable_plainrand();
  public:

  // bytes cipherRand = 2;
  void clear_cipherrand();
  const std::string& cipherrand() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cipherrand(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cipherrand();
  PROTOBUF_NODISCARD std::string* release_cipherrand();
  void set_allocated_cipherrand(std::string* cipherrand);
  private:
  const std::string& _internal_cipherrand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cipherrand(const std::string& value);
  std::string* _internal_mutable_cipherrand();
  public:

  // @@protoc_insertion_point(class_scope:QXSCMsg.ClientRegisterChallengeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plainrand_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cipherrand_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class ServerRegisterFinish final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.ServerRegisterFinish) */ {
 public:
  inline ServerRegisterFinish() : ServerRegisterFinish(nullptr) {}
  ~ServerRegisterFinish() override;
  explicit PROTOBUF_CONSTEXPR ServerRegisterFinish(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerRegisterFinish(const ServerRegisterFinish& from);
  ServerRegisterFinish(ServerRegisterFinish&& from) noexcept
    : ServerRegisterFinish() {
    *this = ::std::move(from);
  }

  inline ServerRegisterFinish& operator=(const ServerRegisterFinish& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerRegisterFinish& operator=(ServerRegisterFinish&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerRegisterFinish& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerRegisterFinish* internal_default_instance() {
    return reinterpret_cast<const ServerRegisterFinish*>(
               &_ServerRegisterFinish_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ServerRegisterFinish& a, ServerRegisterFinish& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerRegisterFinish* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerRegisterFinish* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerRegisterFinish* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerRegisterFinish>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerRegisterFinish& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerRegisterFinish& from) {
    ServerRegisterFinish::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerRegisterFinish* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.ServerRegisterFinish";
  }
  protected:
  explicit ServerRegisterFinish(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlainRandFieldNumber = 1,
    kCipherContentFieldNumber = 2,
  };
  // bytes plainRand = 1;
  void clear_plainrand();
  const std::string& plainrand() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plainrand(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plainrand();
  PROTOBUF_NODISCARD std::string* release_plainrand();
  void set_allocated_plainrand(std::string* plainrand);
  private:
  const std::string& _internal_plainrand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plainrand(const std::string& value);
  std::string* _internal_mutable_plainrand();
  public:

  // .QXSCMsg.CipherContent cipherContent = 2;
  bool has_ciphercontent() const;
  private:
  bool _internal_has_ciphercontent() const;
  public:
  void clear_ciphercontent();
  const ::QXSCMsg::CipherContent& ciphercontent() const;
  PROTOBUF_NODISCARD ::QXSCMsg::CipherContent* release_ciphercontent();
  ::QXSCMsg::CipherContent* mutable_ciphercontent();
  void set_allocated_ciphercontent(::QXSCMsg::CipherContent* ciphercontent);
  private:
  const ::QXSCMsg::CipherContent& _internal_ciphercontent() const;
  ::QXSCMsg::CipherContent* _internal_mutable_ciphercontent();
  public:
  void unsafe_arena_set_allocated_ciphercontent(
      ::QXSCMsg::CipherContent* ciphercontent);
  ::QXSCMsg::CipherContent* unsafe_arena_release_ciphercontent();

  // @@protoc_insertion_point(class_scope:QXSCMsg.ServerRegisterFinish)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plainrand_;
    ::QXSCMsg::CipherContent* ciphercontent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class CipherContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.CipherContent) */ {
 public:
  inline CipherContent() : CipherContent(nullptr) {}
  ~CipherContent() override;
  explicit PROTOBUF_CONSTEXPR CipherContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CipherContent(const CipherContent& from);
  CipherContent(CipherContent&& from) noexcept
    : CipherContent() {
    *this = ::std::move(from);
  }

  inline CipherContent& operator=(const CipherContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CipherContent& operator=(CipherContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CipherContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CipherContent* internal_default_instance() {
    return reinterpret_cast<const CipherContent*>(
               &_CipherContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CipherContent& a, CipherContent& b) {
    a.Swap(&b);
  }
  inline void Swap(CipherContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CipherContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CipherContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CipherContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CipherContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CipherContent& from) {
    CipherContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CipherContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.CipherContent";
  }
  protected:
  explicit CipherContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCipherSM4KeyFieldNumber = 2,
    kCipherSuiteFieldNumber = 1,
  };
  // bytes cipherSM4Key = 2;
  void clear_ciphersm4key();
  const std::string& ciphersm4key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ciphersm4key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ciphersm4key();
  PROTOBUF_NODISCARD std::string* release_ciphersm4key();
  void set_allocated_ciphersm4key(std::string* ciphersm4key);
  private:
  const std::string& _internal_ciphersm4key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ciphersm4key(const std::string& value);
  std::string* _internal_mutable_ciphersm4key();
  public:

  // uint32 cipherSuite = 1;
  void clear_ciphersuite();
  uint32_t ciphersuite() const;
  void set_ciphersuite(uint32_t value);
  private:
  uint32_t _internal_ciphersuite() const;
  void _internal_set_ciphersuite(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QXSCMsg.CipherContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ciphersm4key_;
    uint32_t ciphersuite_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// -------------------------------------------------------------------

class TransMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QXSCMsg.TransMsg) */ {
 public:
  inline TransMsg() : TransMsg(nullptr) {}
  ~TransMsg() override;
  explicit PROTOBUF_CONSTEXPR TransMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransMsg(const TransMsg& from);
  TransMsg(TransMsg&& from) noexcept
    : TransMsg() {
    *this = ::std::move(from);
  }

  inline TransMsg& operator=(const TransMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransMsg& operator=(TransMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransMsg* internal_default_instance() {
    return reinterpret_cast<const TransMsg*>(
               &_TransMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TransMsg& a, TransMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(TransMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransMsg& from) {
    TransMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QXSCMsg.TransMsg";
  }
  protected:
  explicit TransMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .QXSCMsg.ClientInfo from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::QXSCMsg::ClientInfo& from() const;
  PROTOBUF_NODISCARD ::QXSCMsg::ClientInfo* release_from();
  ::QXSCMsg::ClientInfo* mutable_from();
  void set_allocated_from(::QXSCMsg::ClientInfo* from);
  private:
  const ::QXSCMsg::ClientInfo& _internal_from() const;
  ::QXSCMsg::ClientInfo* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::QXSCMsg::ClientInfo* from);
  ::QXSCMsg::ClientInfo* unsafe_arena_release_from();

  // .QXSCMsg.ClientInfo to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::QXSCMsg::ClientInfo& to() const;
  PROTOBUF_NODISCARD ::QXSCMsg::ClientInfo* release_to();
  ::QXSCMsg::ClientInfo* mutable_to();
  void set_allocated_to(::QXSCMsg::ClientInfo* to);
  private:
  const ::QXSCMsg::ClientInfo& _internal_to() const;
  ::QXSCMsg::ClientInfo* _internal_mutable_to();
  public:
  void unsafe_arena_set_allocated_to(
      ::QXSCMsg::ClientInfo* to);
  ::QXSCMsg::ClientInfo* unsafe_arena_release_to();

  // @@protoc_insertion_point(class_scope:QXSCMsg.TransMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::QXSCMsg::ClientInfo* from_;
    ::QXSCMsg::ClientInfo* to_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_QXSCMsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgPayload

// uint32 transId = 1;
inline void MsgPayload::clear_transid() {
  _impl_.transid_ = 0u;
}
inline uint32_t MsgPayload::_internal_transid() const {
  return _impl_.transid_;
}
inline uint32_t MsgPayload::transid() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgPayload.transId)
  return _internal_transid();
}
inline void MsgPayload::_internal_set_transid(uint32_t value) {
  
  _impl_.transid_ = value;
}
inline void MsgPayload::set_transid(uint32_t value) {
  _internal_set_transid(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.MsgPayload.transId)
}

// uint64 timestamp = 2;
inline void MsgPayload::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t MsgPayload::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t MsgPayload::timestamp() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgPayload.timestamp)
  return _internal_timestamp();
}
inline void MsgPayload::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void MsgPayload::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.MsgPayload.timestamp)
}

// string bussinessKey = 3;
inline void MsgPayload::clear_bussinesskey() {
  _impl_.bussinesskey_.ClearToEmpty();
}
inline const std::string& MsgPayload::bussinesskey() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgPayload.bussinessKey)
  return _internal_bussinesskey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgPayload::set_bussinesskey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bussinesskey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QXSCMsg.MsgPayload.bussinessKey)
}
inline std::string* MsgPayload::mutable_bussinesskey() {
  std::string* _s = _internal_mutable_bussinesskey();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgPayload.bussinessKey)
  return _s;
}
inline const std::string& MsgPayload::_internal_bussinesskey() const {
  return _impl_.bussinesskey_.Get();
}
inline void MsgPayload::_internal_set_bussinesskey(const std::string& value) {
  
  _impl_.bussinesskey_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPayload::_internal_mutable_bussinesskey() {
  
  return _impl_.bussinesskey_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgPayload::release_bussinesskey() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgPayload.bussinessKey)
  return _impl_.bussinesskey_.Release();
}
inline void MsgPayload::set_allocated_bussinesskey(std::string* bussinesskey) {
  if (bussinesskey != nullptr) {
    
  } else {
    
  }
  _impl_.bussinesskey_.SetAllocated(bussinesskey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bussinesskey_.IsDefault()) {
    _impl_.bussinesskey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgPayload.bussinessKey)
}

// .QXSCMsg.ClientInfo clientInfo = 4;
inline bool MsgPayload::_internal_has_clientinfo() const {
  return this != internal_default_instance() && _impl_.clientinfo_ != nullptr;
}
inline bool MsgPayload::has_clientinfo() const {
  return _internal_has_clientinfo();
}
inline void MsgPayload::clear_clientinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.clientinfo_ != nullptr) {
    delete _impl_.clientinfo_;
  }
  _impl_.clientinfo_ = nullptr;
}
inline const ::QXSCMsg::ClientInfo& MsgPayload::_internal_clientinfo() const {
  const ::QXSCMsg::ClientInfo* p = _impl_.clientinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::ClientInfo&>(
      ::QXSCMsg::_ClientInfo_default_instance_);
}
inline const ::QXSCMsg::ClientInfo& MsgPayload::clientinfo() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgPayload.clientInfo)
  return _internal_clientinfo();
}
inline void MsgPayload::unsafe_arena_set_allocated_clientinfo(
    ::QXSCMsg::ClientInfo* clientinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clientinfo_);
  }
  _impl_.clientinfo_ = clientinfo;
  if (clientinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.MsgPayload.clientInfo)
}
inline ::QXSCMsg::ClientInfo* MsgPayload::release_clientinfo() {
  
  ::QXSCMsg::ClientInfo* temp = _impl_.clientinfo_;
  _impl_.clientinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::ClientInfo* MsgPayload::unsafe_arena_release_clientinfo() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgPayload.clientInfo)
  
  ::QXSCMsg::ClientInfo* temp = _impl_.clientinfo_;
  _impl_.clientinfo_ = nullptr;
  return temp;
}
inline ::QXSCMsg::ClientInfo* MsgPayload::_internal_mutable_clientinfo() {
  
  if (_impl_.clientinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::ClientInfo>(GetArenaForAllocation());
    _impl_.clientinfo_ = p;
  }
  return _impl_.clientinfo_;
}
inline ::QXSCMsg::ClientInfo* MsgPayload::mutable_clientinfo() {
  ::QXSCMsg::ClientInfo* _msg = _internal_mutable_clientinfo();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgPayload.clientInfo)
  return _msg;
}
inline void MsgPayload::set_allocated_clientinfo(::QXSCMsg::ClientInfo* clientinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clientinfo_;
  }
  if (clientinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clientinfo);
    if (message_arena != submessage_arena) {
      clientinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clientinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clientinfo_ = clientinfo;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgPayload.clientInfo)
}

// .QXSCMsg.ServerInfo serverInfo = 5;
inline bool MsgPayload::_internal_has_serverinfo() const {
  return this != internal_default_instance() && _impl_.serverinfo_ != nullptr;
}
inline bool MsgPayload::has_serverinfo() const {
  return _internal_has_serverinfo();
}
inline void MsgPayload::clear_serverinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.serverinfo_ != nullptr) {
    delete _impl_.serverinfo_;
  }
  _impl_.serverinfo_ = nullptr;
}
inline const ::QXSCMsg::ServerInfo& MsgPayload::_internal_serverinfo() const {
  const ::QXSCMsg::ServerInfo* p = _impl_.serverinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::ServerInfo&>(
      ::QXSCMsg::_ServerInfo_default_instance_);
}
inline const ::QXSCMsg::ServerInfo& MsgPayload::serverinfo() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgPayload.serverInfo)
  return _internal_serverinfo();
}
inline void MsgPayload::unsafe_arena_set_allocated_serverinfo(
    ::QXSCMsg::ServerInfo* serverinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.serverinfo_);
  }
  _impl_.serverinfo_ = serverinfo;
  if (serverinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.MsgPayload.serverInfo)
}
inline ::QXSCMsg::ServerInfo* MsgPayload::release_serverinfo() {
  
  ::QXSCMsg::ServerInfo* temp = _impl_.serverinfo_;
  _impl_.serverinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::ServerInfo* MsgPayload::unsafe_arena_release_serverinfo() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgPayload.serverInfo)
  
  ::QXSCMsg::ServerInfo* temp = _impl_.serverinfo_;
  _impl_.serverinfo_ = nullptr;
  return temp;
}
inline ::QXSCMsg::ServerInfo* MsgPayload::_internal_mutable_serverinfo() {
  
  if (_impl_.serverinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::ServerInfo>(GetArenaForAllocation());
    _impl_.serverinfo_ = p;
  }
  return _impl_.serverinfo_;
}
inline ::QXSCMsg::ServerInfo* MsgPayload::mutable_serverinfo() {
  ::QXSCMsg::ServerInfo* _msg = _internal_mutable_serverinfo();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgPayload.serverInfo)
  return _msg;
}
inline void MsgPayload::set_allocated_serverinfo(::QXSCMsg::ServerInfo* serverinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.serverinfo_;
  }
  if (serverinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(serverinfo);
    if (message_arena != submessage_arena) {
      serverinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serverinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.serverinfo_ = serverinfo;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgPayload.serverInfo)
}

// int32 errCode = 6;
inline void MsgPayload::clear_errcode() {
  _impl_.errcode_ = 0;
}
inline int32_t MsgPayload::_internal_errcode() const {
  return _impl_.errcode_;
}
inline int32_t MsgPayload::errcode() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgPayload.errCode)
  return _internal_errcode();
}
inline void MsgPayload::_internal_set_errcode(int32_t value) {
  
  _impl_.errcode_ = value;
}
inline void MsgPayload::set_errcode(int32_t value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.MsgPayload.errCode)
}

// .QXSCMsg.MsgBase msgBase = 7;
inline bool MsgPayload::_internal_has_msgbase() const {
  return this != internal_default_instance() && _impl_.msgbase_ != nullptr;
}
inline bool MsgPayload::has_msgbase() const {
  return _internal_has_msgbase();
}
inline void MsgPayload::clear_msgbase() {
  if (GetArenaForAllocation() == nullptr && _impl_.msgbase_ != nullptr) {
    delete _impl_.msgbase_;
  }
  _impl_.msgbase_ = nullptr;
}
inline const ::QXSCMsg::MsgBase& MsgPayload::_internal_msgbase() const {
  const ::QXSCMsg::MsgBase* p = _impl_.msgbase_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::MsgBase&>(
      ::QXSCMsg::_MsgBase_default_instance_);
}
inline const ::QXSCMsg::MsgBase& MsgPayload::msgbase() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgPayload.msgBase)
  return _internal_msgbase();
}
inline void MsgPayload::unsafe_arena_set_allocated_msgbase(
    ::QXSCMsg::MsgBase* msgbase) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msgbase_);
  }
  _impl_.msgbase_ = msgbase;
  if (msgbase) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.MsgPayload.msgBase)
}
inline ::QXSCMsg::MsgBase* MsgPayload::release_msgbase() {
  
  ::QXSCMsg::MsgBase* temp = _impl_.msgbase_;
  _impl_.msgbase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::MsgBase* MsgPayload::unsafe_arena_release_msgbase() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgPayload.msgBase)
  
  ::QXSCMsg::MsgBase* temp = _impl_.msgbase_;
  _impl_.msgbase_ = nullptr;
  return temp;
}
inline ::QXSCMsg::MsgBase* MsgPayload::_internal_mutable_msgbase() {
  
  if (_impl_.msgbase_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::MsgBase>(GetArenaForAllocation());
    _impl_.msgbase_ = p;
  }
  return _impl_.msgbase_;
}
inline ::QXSCMsg::MsgBase* MsgPayload::mutable_msgbase() {
  ::QXSCMsg::MsgBase* _msg = _internal_mutable_msgbase();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgPayload.msgBase)
  return _msg;
}
inline void MsgPayload::set_allocated_msgbase(::QXSCMsg::MsgBase* msgbase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msgbase_;
  }
  if (msgbase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msgbase);
    if (message_arena != submessage_arena) {
      msgbase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgbase, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msgbase_ = msgbase;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgPayload.msgBase)
}

// -------------------------------------------------------------------

// ClientInfo

// uint32 clientId = 1;
inline void ClientInfo::clear_clientid() {
  _impl_.clientid_ = 0u;
}
inline uint32_t ClientInfo::_internal_clientid() const {
  return _impl_.clientid_;
}
inline uint32_t ClientInfo::clientid() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ClientInfo.clientId)
  return _internal_clientid();
}
inline void ClientInfo::_internal_set_clientid(uint32_t value) {
  
  _impl_.clientid_ = value;
}
inline void ClientInfo::set_clientid(uint32_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.ClientInfo.clientId)
}

// -------------------------------------------------------------------

// ServerInfo

// uint32 serverId = 1;
inline void ServerInfo::clear_serverid() {
  _impl_.serverid_ = 0u;
}
inline uint32_t ServerInfo::_internal_serverid() const {
  return _impl_.serverid_;
}
inline uint32_t ServerInfo::serverid() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ServerInfo.serverId)
  return _internal_serverid();
}
inline void ServerInfo::_internal_set_serverid(uint32_t value) {
  
  _impl_.serverid_ = value;
}
inline void ServerInfo::set_serverid(uint32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.ServerInfo.serverId)
}

// string serverName = 2;
inline void ServerInfo::clear_servername() {
  _impl_.servername_.ClearToEmpty();
}
inline const std::string& ServerInfo::servername() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ServerInfo.serverName)
  return _internal_servername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_servername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QXSCMsg.ServerInfo.serverName)
}
inline std::string* ServerInfo::mutable_servername() {
  std::string* _s = _internal_mutable_servername();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.ServerInfo.serverName)
  return _s;
}
inline const std::string& ServerInfo::_internal_servername() const {
  return _impl_.servername_.Get();
}
inline void ServerInfo::_internal_set_servername(const std::string& value) {
  
  _impl_.servername_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_servername() {
  
  return _impl_.servername_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_servername() {
  // @@protoc_insertion_point(field_release:QXSCMsg.ServerInfo.serverName)
  return _impl_.servername_.Release();
}
inline void ServerInfo::set_allocated_servername(std::string* servername) {
  if (servername != nullptr) {
    
  } else {
    
  }
  _impl_.servername_.SetAllocated(servername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servername_.IsDefault()) {
    _impl_.servername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.ServerInfo.serverName)
}

// -------------------------------------------------------------------

// MsgBase

// uint32 msgType = 1;
inline void MsgBase::clear_msgtype() {
  _impl_.msgtype_ = 0u;
}
inline uint32_t MsgBase::_internal_msgtype() const {
  return _impl_.msgtype_;
}
inline uint32_t MsgBase::msgtype() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgBase.msgType)
  return _internal_msgtype();
}
inline void MsgBase::_internal_set_msgtype(uint32_t value) {
  
  _impl_.msgtype_ = value;
}
inline void MsgBase::set_msgtype(uint32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.MsgBase.msgType)
}

// .QXSCMsg.ClientRegisterRequest registerRequest = 2;
inline bool MsgBase::_internal_has_registerrequest() const {
  return this != internal_default_instance() && _impl_.registerrequest_ != nullptr;
}
inline bool MsgBase::has_registerrequest() const {
  return _internal_has_registerrequest();
}
inline void MsgBase::clear_registerrequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.registerrequest_ != nullptr) {
    delete _impl_.registerrequest_;
  }
  _impl_.registerrequest_ = nullptr;
}
inline const ::QXSCMsg::ClientRegisterRequest& MsgBase::_internal_registerrequest() const {
  const ::QXSCMsg::ClientRegisterRequest* p = _impl_.registerrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::ClientRegisterRequest&>(
      ::QXSCMsg::_ClientRegisterRequest_default_instance_);
}
inline const ::QXSCMsg::ClientRegisterRequest& MsgBase::registerrequest() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgBase.registerRequest)
  return _internal_registerrequest();
}
inline void MsgBase::unsafe_arena_set_allocated_registerrequest(
    ::QXSCMsg::ClientRegisterRequest* registerrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registerrequest_);
  }
  _impl_.registerrequest_ = registerrequest;
  if (registerrequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.MsgBase.registerRequest)
}
inline ::QXSCMsg::ClientRegisterRequest* MsgBase::release_registerrequest() {
  
  ::QXSCMsg::ClientRegisterRequest* temp = _impl_.registerrequest_;
  _impl_.registerrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::ClientRegisterRequest* MsgBase::unsafe_arena_release_registerrequest() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgBase.registerRequest)
  
  ::QXSCMsg::ClientRegisterRequest* temp = _impl_.registerrequest_;
  _impl_.registerrequest_ = nullptr;
  return temp;
}
inline ::QXSCMsg::ClientRegisterRequest* MsgBase::_internal_mutable_registerrequest() {
  
  if (_impl_.registerrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::ClientRegisterRequest>(GetArenaForAllocation());
    _impl_.registerrequest_ = p;
  }
  return _impl_.registerrequest_;
}
inline ::QXSCMsg::ClientRegisterRequest* MsgBase::mutable_registerrequest() {
  ::QXSCMsg::ClientRegisterRequest* _msg = _internal_mutable_registerrequest();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgBase.registerRequest)
  return _msg;
}
inline void MsgBase::set_allocated_registerrequest(::QXSCMsg::ClientRegisterRequest* registerrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registerrequest_;
  }
  if (registerrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registerrequest);
    if (message_arena != submessage_arena) {
      registerrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registerrequest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registerrequest_ = registerrequest;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgBase.registerRequest)
}

// .QXSCMsg.ServerRegisterChallenge registerChallenge = 3;
inline bool MsgBase::_internal_has_registerchallenge() const {
  return this != internal_default_instance() && _impl_.registerchallenge_ != nullptr;
}
inline bool MsgBase::has_registerchallenge() const {
  return _internal_has_registerchallenge();
}
inline void MsgBase::clear_registerchallenge() {
  if (GetArenaForAllocation() == nullptr && _impl_.registerchallenge_ != nullptr) {
    delete _impl_.registerchallenge_;
  }
  _impl_.registerchallenge_ = nullptr;
}
inline const ::QXSCMsg::ServerRegisterChallenge& MsgBase::_internal_registerchallenge() const {
  const ::QXSCMsg::ServerRegisterChallenge* p = _impl_.registerchallenge_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::ServerRegisterChallenge&>(
      ::QXSCMsg::_ServerRegisterChallenge_default_instance_);
}
inline const ::QXSCMsg::ServerRegisterChallenge& MsgBase::registerchallenge() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgBase.registerChallenge)
  return _internal_registerchallenge();
}
inline void MsgBase::unsafe_arena_set_allocated_registerchallenge(
    ::QXSCMsg::ServerRegisterChallenge* registerchallenge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registerchallenge_);
  }
  _impl_.registerchallenge_ = registerchallenge;
  if (registerchallenge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.MsgBase.registerChallenge)
}
inline ::QXSCMsg::ServerRegisterChallenge* MsgBase::release_registerchallenge() {
  
  ::QXSCMsg::ServerRegisterChallenge* temp = _impl_.registerchallenge_;
  _impl_.registerchallenge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::ServerRegisterChallenge* MsgBase::unsafe_arena_release_registerchallenge() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgBase.registerChallenge)
  
  ::QXSCMsg::ServerRegisterChallenge* temp = _impl_.registerchallenge_;
  _impl_.registerchallenge_ = nullptr;
  return temp;
}
inline ::QXSCMsg::ServerRegisterChallenge* MsgBase::_internal_mutable_registerchallenge() {
  
  if (_impl_.registerchallenge_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::ServerRegisterChallenge>(GetArenaForAllocation());
    _impl_.registerchallenge_ = p;
  }
  return _impl_.registerchallenge_;
}
inline ::QXSCMsg::ServerRegisterChallenge* MsgBase::mutable_registerchallenge() {
  ::QXSCMsg::ServerRegisterChallenge* _msg = _internal_mutable_registerchallenge();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgBase.registerChallenge)
  return _msg;
}
inline void MsgBase::set_allocated_registerchallenge(::QXSCMsg::ServerRegisterChallenge* registerchallenge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registerchallenge_;
  }
  if (registerchallenge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registerchallenge);
    if (message_arena != submessage_arena) {
      registerchallenge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registerchallenge, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registerchallenge_ = registerchallenge;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgBase.registerChallenge)
}

// .QXSCMsg.ClientRegisterChallengeReply registerChallengeReply = 4;
inline bool MsgBase::_internal_has_registerchallengereply() const {
  return this != internal_default_instance() && _impl_.registerchallengereply_ != nullptr;
}
inline bool MsgBase::has_registerchallengereply() const {
  return _internal_has_registerchallengereply();
}
inline void MsgBase::clear_registerchallengereply() {
  if (GetArenaForAllocation() == nullptr && _impl_.registerchallengereply_ != nullptr) {
    delete _impl_.registerchallengereply_;
  }
  _impl_.registerchallengereply_ = nullptr;
}
inline const ::QXSCMsg::ClientRegisterChallengeReply& MsgBase::_internal_registerchallengereply() const {
  const ::QXSCMsg::ClientRegisterChallengeReply* p = _impl_.registerchallengereply_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::ClientRegisterChallengeReply&>(
      ::QXSCMsg::_ClientRegisterChallengeReply_default_instance_);
}
inline const ::QXSCMsg::ClientRegisterChallengeReply& MsgBase::registerchallengereply() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgBase.registerChallengeReply)
  return _internal_registerchallengereply();
}
inline void MsgBase::unsafe_arena_set_allocated_registerchallengereply(
    ::QXSCMsg::ClientRegisterChallengeReply* registerchallengereply) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registerchallengereply_);
  }
  _impl_.registerchallengereply_ = registerchallengereply;
  if (registerchallengereply) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.MsgBase.registerChallengeReply)
}
inline ::QXSCMsg::ClientRegisterChallengeReply* MsgBase::release_registerchallengereply() {
  
  ::QXSCMsg::ClientRegisterChallengeReply* temp = _impl_.registerchallengereply_;
  _impl_.registerchallengereply_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::ClientRegisterChallengeReply* MsgBase::unsafe_arena_release_registerchallengereply() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgBase.registerChallengeReply)
  
  ::QXSCMsg::ClientRegisterChallengeReply* temp = _impl_.registerchallengereply_;
  _impl_.registerchallengereply_ = nullptr;
  return temp;
}
inline ::QXSCMsg::ClientRegisterChallengeReply* MsgBase::_internal_mutable_registerchallengereply() {
  
  if (_impl_.registerchallengereply_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::ClientRegisterChallengeReply>(GetArenaForAllocation());
    _impl_.registerchallengereply_ = p;
  }
  return _impl_.registerchallengereply_;
}
inline ::QXSCMsg::ClientRegisterChallengeReply* MsgBase::mutable_registerchallengereply() {
  ::QXSCMsg::ClientRegisterChallengeReply* _msg = _internal_mutable_registerchallengereply();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgBase.registerChallengeReply)
  return _msg;
}
inline void MsgBase::set_allocated_registerchallengereply(::QXSCMsg::ClientRegisterChallengeReply* registerchallengereply) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registerchallengereply_;
  }
  if (registerchallengereply) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registerchallengereply);
    if (message_arena != submessage_arena) {
      registerchallengereply = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registerchallengereply, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registerchallengereply_ = registerchallengereply;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgBase.registerChallengeReply)
}

// .QXSCMsg.ServerRegisterFinish registerFinish = 5;
inline bool MsgBase::_internal_has_registerfinish() const {
  return this != internal_default_instance() && _impl_.registerfinish_ != nullptr;
}
inline bool MsgBase::has_registerfinish() const {
  return _internal_has_registerfinish();
}
inline void MsgBase::clear_registerfinish() {
  if (GetArenaForAllocation() == nullptr && _impl_.registerfinish_ != nullptr) {
    delete _impl_.registerfinish_;
  }
  _impl_.registerfinish_ = nullptr;
}
inline const ::QXSCMsg::ServerRegisterFinish& MsgBase::_internal_registerfinish() const {
  const ::QXSCMsg::ServerRegisterFinish* p = _impl_.registerfinish_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::ServerRegisterFinish&>(
      ::QXSCMsg::_ServerRegisterFinish_default_instance_);
}
inline const ::QXSCMsg::ServerRegisterFinish& MsgBase::registerfinish() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgBase.registerFinish)
  return _internal_registerfinish();
}
inline void MsgBase::unsafe_arena_set_allocated_registerfinish(
    ::QXSCMsg::ServerRegisterFinish* registerfinish) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registerfinish_);
  }
  _impl_.registerfinish_ = registerfinish;
  if (registerfinish) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.MsgBase.registerFinish)
}
inline ::QXSCMsg::ServerRegisterFinish* MsgBase::release_registerfinish() {
  
  ::QXSCMsg::ServerRegisterFinish* temp = _impl_.registerfinish_;
  _impl_.registerfinish_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::ServerRegisterFinish* MsgBase::unsafe_arena_release_registerfinish() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgBase.registerFinish)
  
  ::QXSCMsg::ServerRegisterFinish* temp = _impl_.registerfinish_;
  _impl_.registerfinish_ = nullptr;
  return temp;
}
inline ::QXSCMsg::ServerRegisterFinish* MsgBase::_internal_mutable_registerfinish() {
  
  if (_impl_.registerfinish_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::ServerRegisterFinish>(GetArenaForAllocation());
    _impl_.registerfinish_ = p;
  }
  return _impl_.registerfinish_;
}
inline ::QXSCMsg::ServerRegisterFinish* MsgBase::mutable_registerfinish() {
  ::QXSCMsg::ServerRegisterFinish* _msg = _internal_mutable_registerfinish();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgBase.registerFinish)
  return _msg;
}
inline void MsgBase::set_allocated_registerfinish(::QXSCMsg::ServerRegisterFinish* registerfinish) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registerfinish_;
  }
  if (registerfinish) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registerfinish);
    if (message_arena != submessage_arena) {
      registerfinish = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registerfinish, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registerfinish_ = registerfinish;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgBase.registerFinish)
}

// .QXSCMsg.TransMsg transMsg = 6;
inline bool MsgBase::_internal_has_transmsg() const {
  return this != internal_default_instance() && _impl_.transmsg_ != nullptr;
}
inline bool MsgBase::has_transmsg() const {
  return _internal_has_transmsg();
}
inline void MsgBase::clear_transmsg() {
  if (GetArenaForAllocation() == nullptr && _impl_.transmsg_ != nullptr) {
    delete _impl_.transmsg_;
  }
  _impl_.transmsg_ = nullptr;
}
inline const ::QXSCMsg::TransMsg& MsgBase::_internal_transmsg() const {
  const ::QXSCMsg::TransMsg* p = _impl_.transmsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::TransMsg&>(
      ::QXSCMsg::_TransMsg_default_instance_);
}
inline const ::QXSCMsg::TransMsg& MsgBase::transmsg() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.MsgBase.transMsg)
  return _internal_transmsg();
}
inline void MsgBase::unsafe_arena_set_allocated_transmsg(
    ::QXSCMsg::TransMsg* transmsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transmsg_);
  }
  _impl_.transmsg_ = transmsg;
  if (transmsg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.MsgBase.transMsg)
}
inline ::QXSCMsg::TransMsg* MsgBase::release_transmsg() {
  
  ::QXSCMsg::TransMsg* temp = _impl_.transmsg_;
  _impl_.transmsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::TransMsg* MsgBase::unsafe_arena_release_transmsg() {
  // @@protoc_insertion_point(field_release:QXSCMsg.MsgBase.transMsg)
  
  ::QXSCMsg::TransMsg* temp = _impl_.transmsg_;
  _impl_.transmsg_ = nullptr;
  return temp;
}
inline ::QXSCMsg::TransMsg* MsgBase::_internal_mutable_transmsg() {
  
  if (_impl_.transmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::TransMsg>(GetArenaForAllocation());
    _impl_.transmsg_ = p;
  }
  return _impl_.transmsg_;
}
inline ::QXSCMsg::TransMsg* MsgBase::mutable_transmsg() {
  ::QXSCMsg::TransMsg* _msg = _internal_mutable_transmsg();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.MsgBase.transMsg)
  return _msg;
}
inline void MsgBase::set_allocated_transmsg(::QXSCMsg::TransMsg* transmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transmsg_;
  }
  if (transmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transmsg);
    if (message_arena != submessage_arena) {
      transmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transmsg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transmsg_ = transmsg;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.MsgBase.transMsg)
}

// -------------------------------------------------------------------

// ClientRegisterRequest

// uint32 clientId = 1;
inline void ClientRegisterRequest::clear_clientid() {
  _impl_.clientid_ = 0u;
}
inline uint32_t ClientRegisterRequest::_internal_clientid() const {
  return _impl_.clientid_;
}
inline uint32_t ClientRegisterRequest::clientid() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ClientRegisterRequest.clientId)
  return _internal_clientid();
}
inline void ClientRegisterRequest::_internal_set_clientid(uint32_t value) {
  
  _impl_.clientid_ = value;
}
inline void ClientRegisterRequest::set_clientid(uint32_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.ClientRegisterRequest.clientId)
}

// uint32 cipherSuite = 2;
inline void ClientRegisterRequest::clear_ciphersuite() {
  _impl_.ciphersuite_ = 0u;
}
inline uint32_t ClientRegisterRequest::_internal_ciphersuite() const {
  return _impl_.ciphersuite_;
}
inline uint32_t ClientRegisterRequest::ciphersuite() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ClientRegisterRequest.cipherSuite)
  return _internal_ciphersuite();
}
inline void ClientRegisterRequest::_internal_set_ciphersuite(uint32_t value) {
  
  _impl_.ciphersuite_ = value;
}
inline void ClientRegisterRequest::set_ciphersuite(uint32_t value) {
  _internal_set_ciphersuite(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.ClientRegisterRequest.cipherSuite)
}

// -------------------------------------------------------------------

// ServerRegisterChallenge

// bytes cipherRand = 1;
inline void ServerRegisterChallenge::clear_cipherrand() {
  _impl_.cipherrand_.ClearToEmpty();
}
inline const std::string& ServerRegisterChallenge::cipherrand() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ServerRegisterChallenge.cipherRand)
  return _internal_cipherrand();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerRegisterChallenge::set_cipherrand(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cipherrand_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QXSCMsg.ServerRegisterChallenge.cipherRand)
}
inline std::string* ServerRegisterChallenge::mutable_cipherrand() {
  std::string* _s = _internal_mutable_cipherrand();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.ServerRegisterChallenge.cipherRand)
  return _s;
}
inline const std::string& ServerRegisterChallenge::_internal_cipherrand() const {
  return _impl_.cipherrand_.Get();
}
inline void ServerRegisterChallenge::_internal_set_cipherrand(const std::string& value) {
  
  _impl_.cipherrand_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerRegisterChallenge::_internal_mutable_cipherrand() {
  
  return _impl_.cipherrand_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerRegisterChallenge::release_cipherrand() {
  // @@protoc_insertion_point(field_release:QXSCMsg.ServerRegisterChallenge.cipherRand)
  return _impl_.cipherrand_.Release();
}
inline void ServerRegisterChallenge::set_allocated_cipherrand(std::string* cipherrand) {
  if (cipherrand != nullptr) {
    
  } else {
    
  }
  _impl_.cipherrand_.SetAllocated(cipherrand, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cipherrand_.IsDefault()) {
    _impl_.cipherrand_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.ServerRegisterChallenge.cipherRand)
}

// -------------------------------------------------------------------

// ClientRegisterChallengeReply

// bytes plainRand = 1;
inline void ClientRegisterChallengeReply::clear_plainrand() {
  _impl_.plainrand_.ClearToEmpty();
}
inline const std::string& ClientRegisterChallengeReply::plainrand() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ClientRegisterChallengeReply.plainRand)
  return _internal_plainrand();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientRegisterChallengeReply::set_plainrand(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plainrand_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QXSCMsg.ClientRegisterChallengeReply.plainRand)
}
inline std::string* ClientRegisterChallengeReply::mutable_plainrand() {
  std::string* _s = _internal_mutable_plainrand();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.ClientRegisterChallengeReply.plainRand)
  return _s;
}
inline const std::string& ClientRegisterChallengeReply::_internal_plainrand() const {
  return _impl_.plainrand_.Get();
}
inline void ClientRegisterChallengeReply::_internal_set_plainrand(const std::string& value) {
  
  _impl_.plainrand_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientRegisterChallengeReply::_internal_mutable_plainrand() {
  
  return _impl_.plainrand_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientRegisterChallengeReply::release_plainrand() {
  // @@protoc_insertion_point(field_release:QXSCMsg.ClientRegisterChallengeReply.plainRand)
  return _impl_.plainrand_.Release();
}
inline void ClientRegisterChallengeReply::set_allocated_plainrand(std::string* plainrand) {
  if (plainrand != nullptr) {
    
  } else {
    
  }
  _impl_.plainrand_.SetAllocated(plainrand, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plainrand_.IsDefault()) {
    _impl_.plainrand_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.ClientRegisterChallengeReply.plainRand)
}

// bytes cipherRand = 2;
inline void ClientRegisterChallengeReply::clear_cipherrand() {
  _impl_.cipherrand_.ClearToEmpty();
}
inline const std::string& ClientRegisterChallengeReply::cipherrand() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ClientRegisterChallengeReply.cipherRand)
  return _internal_cipherrand();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientRegisterChallengeReply::set_cipherrand(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cipherrand_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QXSCMsg.ClientRegisterChallengeReply.cipherRand)
}
inline std::string* ClientRegisterChallengeReply::mutable_cipherrand() {
  std::string* _s = _internal_mutable_cipherrand();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.ClientRegisterChallengeReply.cipherRand)
  return _s;
}
inline const std::string& ClientRegisterChallengeReply::_internal_cipherrand() const {
  return _impl_.cipherrand_.Get();
}
inline void ClientRegisterChallengeReply::_internal_set_cipherrand(const std::string& value) {
  
  _impl_.cipherrand_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientRegisterChallengeReply::_internal_mutable_cipherrand() {
  
  return _impl_.cipherrand_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientRegisterChallengeReply::release_cipherrand() {
  // @@protoc_insertion_point(field_release:QXSCMsg.ClientRegisterChallengeReply.cipherRand)
  return _impl_.cipherrand_.Release();
}
inline void ClientRegisterChallengeReply::set_allocated_cipherrand(std::string* cipherrand) {
  if (cipherrand != nullptr) {
    
  } else {
    
  }
  _impl_.cipherrand_.SetAllocated(cipherrand, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cipherrand_.IsDefault()) {
    _impl_.cipherrand_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.ClientRegisterChallengeReply.cipherRand)
}

// -------------------------------------------------------------------

// ServerRegisterFinish

// bytes plainRand = 1;
inline void ServerRegisterFinish::clear_plainrand() {
  _impl_.plainrand_.ClearToEmpty();
}
inline const std::string& ServerRegisterFinish::plainrand() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ServerRegisterFinish.plainRand)
  return _internal_plainrand();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerRegisterFinish::set_plainrand(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plainrand_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QXSCMsg.ServerRegisterFinish.plainRand)
}
inline std::string* ServerRegisterFinish::mutable_plainrand() {
  std::string* _s = _internal_mutable_plainrand();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.ServerRegisterFinish.plainRand)
  return _s;
}
inline const std::string& ServerRegisterFinish::_internal_plainrand() const {
  return _impl_.plainrand_.Get();
}
inline void ServerRegisterFinish::_internal_set_plainrand(const std::string& value) {
  
  _impl_.plainrand_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerRegisterFinish::_internal_mutable_plainrand() {
  
  return _impl_.plainrand_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerRegisterFinish::release_plainrand() {
  // @@protoc_insertion_point(field_release:QXSCMsg.ServerRegisterFinish.plainRand)
  return _impl_.plainrand_.Release();
}
inline void ServerRegisterFinish::set_allocated_plainrand(std::string* plainrand) {
  if (plainrand != nullptr) {
    
  } else {
    
  }
  _impl_.plainrand_.SetAllocated(plainrand, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plainrand_.IsDefault()) {
    _impl_.plainrand_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.ServerRegisterFinish.plainRand)
}

// .QXSCMsg.CipherContent cipherContent = 2;
inline bool ServerRegisterFinish::_internal_has_ciphercontent() const {
  return this != internal_default_instance() && _impl_.ciphercontent_ != nullptr;
}
inline bool ServerRegisterFinish::has_ciphercontent() const {
  return _internal_has_ciphercontent();
}
inline void ServerRegisterFinish::clear_ciphercontent() {
  if (GetArenaForAllocation() == nullptr && _impl_.ciphercontent_ != nullptr) {
    delete _impl_.ciphercontent_;
  }
  _impl_.ciphercontent_ = nullptr;
}
inline const ::QXSCMsg::CipherContent& ServerRegisterFinish::_internal_ciphercontent() const {
  const ::QXSCMsg::CipherContent* p = _impl_.ciphercontent_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::CipherContent&>(
      ::QXSCMsg::_CipherContent_default_instance_);
}
inline const ::QXSCMsg::CipherContent& ServerRegisterFinish::ciphercontent() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.ServerRegisterFinish.cipherContent)
  return _internal_ciphercontent();
}
inline void ServerRegisterFinish::unsafe_arena_set_allocated_ciphercontent(
    ::QXSCMsg::CipherContent* ciphercontent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ciphercontent_);
  }
  _impl_.ciphercontent_ = ciphercontent;
  if (ciphercontent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.ServerRegisterFinish.cipherContent)
}
inline ::QXSCMsg::CipherContent* ServerRegisterFinish::release_ciphercontent() {
  
  ::QXSCMsg::CipherContent* temp = _impl_.ciphercontent_;
  _impl_.ciphercontent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::CipherContent* ServerRegisterFinish::unsafe_arena_release_ciphercontent() {
  // @@protoc_insertion_point(field_release:QXSCMsg.ServerRegisterFinish.cipherContent)
  
  ::QXSCMsg::CipherContent* temp = _impl_.ciphercontent_;
  _impl_.ciphercontent_ = nullptr;
  return temp;
}
inline ::QXSCMsg::CipherContent* ServerRegisterFinish::_internal_mutable_ciphercontent() {
  
  if (_impl_.ciphercontent_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::CipherContent>(GetArenaForAllocation());
    _impl_.ciphercontent_ = p;
  }
  return _impl_.ciphercontent_;
}
inline ::QXSCMsg::CipherContent* ServerRegisterFinish::mutable_ciphercontent() {
  ::QXSCMsg::CipherContent* _msg = _internal_mutable_ciphercontent();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.ServerRegisterFinish.cipherContent)
  return _msg;
}
inline void ServerRegisterFinish::set_allocated_ciphercontent(::QXSCMsg::CipherContent* ciphercontent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ciphercontent_;
  }
  if (ciphercontent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ciphercontent);
    if (message_arena != submessage_arena) {
      ciphercontent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ciphercontent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ciphercontent_ = ciphercontent;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.ServerRegisterFinish.cipherContent)
}

// -------------------------------------------------------------------

// CipherContent

// uint32 cipherSuite = 1;
inline void CipherContent::clear_ciphersuite() {
  _impl_.ciphersuite_ = 0u;
}
inline uint32_t CipherContent::_internal_ciphersuite() const {
  return _impl_.ciphersuite_;
}
inline uint32_t CipherContent::ciphersuite() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.CipherContent.cipherSuite)
  return _internal_ciphersuite();
}
inline void CipherContent::_internal_set_ciphersuite(uint32_t value) {
  
  _impl_.ciphersuite_ = value;
}
inline void CipherContent::set_ciphersuite(uint32_t value) {
  _internal_set_ciphersuite(value);
  // @@protoc_insertion_point(field_set:QXSCMsg.CipherContent.cipherSuite)
}

// bytes cipherSM4Key = 2;
inline void CipherContent::clear_ciphersm4key() {
  _impl_.ciphersm4key_.ClearToEmpty();
}
inline const std::string& CipherContent::ciphersm4key() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.CipherContent.cipherSM4Key)
  return _internal_ciphersm4key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CipherContent::set_ciphersm4key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ciphersm4key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QXSCMsg.CipherContent.cipherSM4Key)
}
inline std::string* CipherContent::mutable_ciphersm4key() {
  std::string* _s = _internal_mutable_ciphersm4key();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.CipherContent.cipherSM4Key)
  return _s;
}
inline const std::string& CipherContent::_internal_ciphersm4key() const {
  return _impl_.ciphersm4key_.Get();
}
inline void CipherContent::_internal_set_ciphersm4key(const std::string& value) {
  
  _impl_.ciphersm4key_.Set(value, GetArenaForAllocation());
}
inline std::string* CipherContent::_internal_mutable_ciphersm4key() {
  
  return _impl_.ciphersm4key_.Mutable(GetArenaForAllocation());
}
inline std::string* CipherContent::release_ciphersm4key() {
  // @@protoc_insertion_point(field_release:QXSCMsg.CipherContent.cipherSM4Key)
  return _impl_.ciphersm4key_.Release();
}
inline void CipherContent::set_allocated_ciphersm4key(std::string* ciphersm4key) {
  if (ciphersm4key != nullptr) {
    
  } else {
    
  }
  _impl_.ciphersm4key_.SetAllocated(ciphersm4key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ciphersm4key_.IsDefault()) {
    _impl_.ciphersm4key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.CipherContent.cipherSM4Key)
}

// -------------------------------------------------------------------

// TransMsg

// .QXSCMsg.ClientInfo from = 1;
inline bool TransMsg::_internal_has_from() const {
  return this != internal_default_instance() && _impl_.from_ != nullptr;
}
inline bool TransMsg::has_from() const {
  return _internal_has_from();
}
inline void TransMsg::clear_from() {
  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
}
inline const ::QXSCMsg::ClientInfo& TransMsg::_internal_from() const {
  const ::QXSCMsg::ClientInfo* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::ClientInfo&>(
      ::QXSCMsg::_ClientInfo_default_instance_);
}
inline const ::QXSCMsg::ClientInfo& TransMsg::from() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.TransMsg.from)
  return _internal_from();
}
inline void TransMsg::unsafe_arena_set_allocated_from(
    ::QXSCMsg::ClientInfo* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.TransMsg.from)
}
inline ::QXSCMsg::ClientInfo* TransMsg::release_from() {
  
  ::QXSCMsg::ClientInfo* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::ClientInfo* TransMsg::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:QXSCMsg.TransMsg.from)
  
  ::QXSCMsg::ClientInfo* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::QXSCMsg::ClientInfo* TransMsg::_internal_mutable_from() {
  
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::ClientInfo>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::QXSCMsg::ClientInfo* TransMsg::mutable_from() {
  ::QXSCMsg::ClientInfo* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.TransMsg.from)
  return _msg;
}
inline void TransMsg::set_allocated_from(::QXSCMsg::ClientInfo* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.TransMsg.from)
}

// .QXSCMsg.ClientInfo to = 2;
inline bool TransMsg::_internal_has_to() const {
  return this != internal_default_instance() && _impl_.to_ != nullptr;
}
inline bool TransMsg::has_to() const {
  return _internal_has_to();
}
inline void TransMsg::clear_to() {
  if (GetArenaForAllocation() == nullptr && _impl_.to_ != nullptr) {
    delete _impl_.to_;
  }
  _impl_.to_ = nullptr;
}
inline const ::QXSCMsg::ClientInfo& TransMsg::_internal_to() const {
  const ::QXSCMsg::ClientInfo* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::QXSCMsg::ClientInfo&>(
      ::QXSCMsg::_ClientInfo_default_instance_);
}
inline const ::QXSCMsg::ClientInfo& TransMsg::to() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.TransMsg.to)
  return _internal_to();
}
inline void TransMsg::unsafe_arena_set_allocated_to(
    ::QXSCMsg::ClientInfo* to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = to;
  if (to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:QXSCMsg.TransMsg.to)
}
inline ::QXSCMsg::ClientInfo* TransMsg::release_to() {
  
  ::QXSCMsg::ClientInfo* temp = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QXSCMsg::ClientInfo* TransMsg::unsafe_arena_release_to() {
  // @@protoc_insertion_point(field_release:QXSCMsg.TransMsg.to)
  
  ::QXSCMsg::ClientInfo* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::QXSCMsg::ClientInfo* TransMsg::_internal_mutable_to() {
  
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::QXSCMsg::ClientInfo>(GetArenaForAllocation());
    _impl_.to_ = p;
  }
  return _impl_.to_;
}
inline ::QXSCMsg::ClientInfo* TransMsg::mutable_to() {
  ::QXSCMsg::ClientInfo* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.TransMsg.to)
  return _msg;
}
inline void TransMsg::set_allocated_to(::QXSCMsg::ClientInfo* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to);
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.to_ = to;
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.TransMsg.to)
}

// string msg = 3;
inline void TransMsg::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& TransMsg::msg() const {
  // @@protoc_insertion_point(field_get:QXSCMsg.TransMsg.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransMsg::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QXSCMsg.TransMsg.msg)
}
inline std::string* TransMsg::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:QXSCMsg.TransMsg.msg)
  return _s;
}
inline const std::string& TransMsg::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void TransMsg::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* TransMsg::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* TransMsg::release_msg() {
  // @@protoc_insertion_point(field_release:QXSCMsg.TransMsg.msg)
  return _impl_.msg_.Release();
}
inline void TransMsg::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QXSCMsg.TransMsg.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace QXSCMsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::QXSCMsg::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::QXSCMsg::MsgType>() {
  return ::QXSCMsg::MsgType_descriptor();
}
template <> struct is_proto_enum< ::QXSCMsg::CipherSuite> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::QXSCMsg::CipherSuite>() {
  return ::QXSCMsg::CipherSuite_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_QXSCMsg_2eproto
